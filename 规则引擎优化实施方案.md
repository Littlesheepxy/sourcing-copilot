# Boss直聘Sourcing智能助手 - 规则引擎简化方案

## 1. 简化目标

基于Fuse.js的模糊搜索能力，对规则引擎进行全面简化，实现：
1. 口语化的规则定义方式
2. 直观易懂的用户界面
3. 降低用户认知负担
4. 保留核心筛选功能

## 2. 数据结构简化

### 2.1 简化规则结构

```typescript
// 简化后的规则类型
export enum SimpleRuleType {
  岗位 = "岗位",
  公司 = "公司",
  技能 = "技能", 
  学校 = "学校",
  学历 = "学历"
}

// 重要性级别
export enum ImportanceLevel {
  不重要 = 25,
  一般 = 50,
  重要 = 75,
  非常重要 = 100
}

// 简化后的规则结构
export interface SimpleRule {
  id: string;                            // 规则唯一标识
  type: SimpleRuleType;                  // 规则类型
  keywords: string[];                    // 关键词列表
  importance: ImportanceLevel;           // 重要性
  mustMatch: boolean;                    // 必须满足
  enabled: boolean;                      // 是否启用
}

// 整体规则配置
export interface SimpleRulesConfig {
  rules: SimpleRule[];                   // 规则列表
  passScore: number;                     // 通过分数(0-100)
  autoMode: boolean;                     // 自动模式
}

// 评估结果
export interface SimpleEvaluationResult {
  candidateId: string;                   // 候选人ID
  candidateName?: string;                // 候选人姓名
  score: number;                         // 总分(0-100)
  passed: boolean;                       // 是否通过筛选
  details: {                             // 详细结果
    ruleType: SimpleRuleType;            // 规则类型
    matched: boolean;                    // 是否匹配
    keywords: string[];                  // 关键词
    matchedKeywords?: string[];          // 匹配的关键词
    importance: ImportanceLevel;         // 重要性
  }[];
  failedMustMatchRule?: SimpleRuleType;  // 未通过的必须条件
  action: "greet" | "skip" | "manual";   // 建议操作
}
```

## 3. 规则引擎简化

### 3.1 规则评估逻辑

```typescript
export class SimpleRulesEngine {
  /**
   * 评估候选人
   */
  public evaluateCandidate(candidate: CandidateData, config: SimpleRulesConfig): SimpleEvaluationResult {
    // 初始化结果
    const result: SimpleEvaluationResult = {
      candidateId: candidate.id,
      candidateName: candidate.name,
      score: 0,
      passed: false,
      details: [],
      action: config.autoMode ? "manual" : "manual"
    };

    // 启用的规则
    const activeRules = config.rules.filter(r => r.enabled);
    
    // 检查必须匹配的规则
    const mustMatchRules = activeRules.filter(r => r.mustMatch);
    for (const rule of mustMatchRules) {
      const matched = this.matchRule(candidate, rule);
      result.details.push({
        ruleType: rule.type,
        matched: matched.matched,
        keywords: rule.keywords,
        matchedKeywords: matched.matchedKeywords,
        importance: rule.importance
      });
      
      if (!matched.matched) {
        // 必须条件不满足
        result.failedMustMatchRule = rule.type;
        result.passed = false;
        result.action = "skip";
        return result;
      }
    }
    
    // 评估一般规则
    let totalScore = 0;
    let totalWeight = 0;
    
    for (const rule of activeRules) {
      if (rule.mustMatch) continue; // 已经评估过必须条件
      
      const importance = rule.importance;
      const matched = this.matchRule(candidate, rule);
      
      result.details.push({
        ruleType: rule.type,
        matched: matched.matched,
        keywords: rule.keywords,
        matchedKeywords: matched.matchedKeywords,
        importance: rule.importance
      });
      
      if (matched.matched) {
        totalScore += importance;
      }
      
      totalWeight += importance;
    }
    
    // 计算最终得分
    result.score = totalWeight > 0 ? Math.round((totalScore / totalWeight) * 100) : 0;
    result.passed = result.score >= config.passScore;
    result.action = config.autoMode ? (result.passed ? "greet" : "skip") : "manual";
    
    return result;
  }
  
  /**
   * 匹配单条规则
   */
  private matchRule(candidate: CandidateData, rule: SimpleRule): { matched: boolean, matchedKeywords: string[] } {
    let fieldValue: any;
    let matched = false;
    let matchedKeywords: string[] = [];
    
    // 根据规则类型获取相应字段值
    switch (rule.type) {
      case SimpleRuleType.岗位:
        fieldValue = candidate.position || '';
        break;
      case SimpleRuleType.公司:
        fieldValue = candidate.company || [];
        break;
      case SimpleRuleType.技能:
        fieldValue = candidate.skills || [];
        break;
      case SimpleRuleType.学校:
        fieldValue = candidate.schools || [];
        break;
      case SimpleRuleType.学历:
        fieldValue = candidate.education || '';
        break;
    }
    
    // 使用Fuse.js进行模糊匹配
    if (fieldValue) {
      // 将字段值转为数组
      const fieldValues = Array.isArray(fieldValue) ? fieldValue : [fieldValue];
      
      // 遍历所有关键词
      for (const keyword of rule.keywords) {
        // 使用Fuse.js搜索
        const fuse = new Fuse(fieldValues, {
          includeScore: true,
          threshold: 0.4, // 匹配阈值
          ignoreLocation: true
        });
        
        const searchResult = fuse.search(keyword);
        
        // 有匹配结果
        if (searchResult.length > 0) {
          matched = true;
          matchedKeywords.push(keyword);
        }
      }
    }
    
    return { matched, matchedKeywords };
  }
}
```

## 4. UI设计简化

### 4.1 规则卡片设计

```html
<!-- 简化的规则卡片 -->
<div class="rule-card" data-rule-type="岗位">
  <div class="rule-header">
    <div class="rule-icon">👨‍💻</div>
    <div class="rule-title">岗位</div>
    <div class="rule-toggle">
      <label class="switch">
        <input type="checkbox" checked>
        <span class="slider round"></span>
      </label>
    </div>
  </div>
  
  <div class="rule-body">
    <!-- 关键词输入 -->
    <div class="keyword-input">
      <input type="text" placeholder="输入关键词，回车添加" class="tag-input">
      <div class="tags-container">
        <!-- 关键词标签区域 -->
      </div>
    </div>
    
    <!-- 重要性设置 -->
    <div class="importance-slider">
      <span>重要性：</span>
      <input type="range" min="1" max="4" value="2" class="range-slider">
      <span class="importance-label">一般</span>
    </div>
    
    <!-- 必须满足复选框 -->
    <label class="must-match">
      <input type="checkbox">
      <span>必须满足此条件</span>
    </label>
  </div>
</div>
```

### 4.2 简化的CSS样式

```css
/* 规则卡片样式 */
.rule-card {
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin-bottom: 16px;
  overflow: hidden;
  transition: transform 0.2s;
}

.rule-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

/* 规则标题区 */
.rule-header {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  background-color: #f5f7fa;
  border-bottom: 1px solid #e2e8f0;
}

.rule-icon {
  font-size: 20px;
  margin-right: 8px;
}

.rule-title {
  font-weight: 600;
  flex: 1;
}

/* 规则内容区 */
.rule-body {
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* 标签输入框 */
.keyword-input {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.tag-input {
  padding: 8px 12px;
  border: 1px solid #e2e8f0;
  border-radius: 4px;
}

.tags-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.tag {
  display: inline-flex;
  align-items: center;
  background-color: #edf2f7;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 14px;
}

.tag .remove-tag {
  margin-left: 4px;
  background: none;
  border: none;
  cursor: pointer;
  color: #a0aec0;
}

/* 重要性滑块 */
.importance-slider {
  display: flex;
  align-items: center;
  gap: 8px;
}

.range-slider {
  flex: 1;
  height: 4px;
}

.importance-label {
  min-width: 60px;
  text-align: right;
  font-size: 14px;
}

/* 规则类型颜色 */
.rule-card[data-rule-type="岗位"] .rule-header {
  border-left: 4px solid #4F46E5;
}

.rule-card[data-rule-type="公司"] .rule-header {
  border-left: 4px solid #0EA5E9;
}

.rule-card[data-rule-type="技能"] .rule-header {
  border-left: 4px solid #10B981;
}

.rule-card[data-rule-type="学校"] .rule-header {
  border-left: 4px solid #F59E0B;
}

.rule-card[data-rule-type="学历"] .rule-header {
  border-left: 4px solid #EC4899;
}
```

### 4.3 简化的JS逻辑

```javascript
document.addEventListener('DOMContentLoaded', () => {
  // 初始化规则管理
  initRuleManager();
});

// 规则管理
function initRuleManager() {
  // 添加规则按钮
  const addRuleBtn = document.getElementById('add-rule-btn');
  
  // 规则类型选择
  addRuleBtn.addEventListener('click', () => {
    showRuleTypeSelector();
  });
  
  // 初始化已有规则卡片
  initExistingRules();
}

// 显示规则类型选择器
function showRuleTypeSelector() {
  const ruleTypes = [
    { type: '岗位', icon: '👨‍💻' },
    { type: '公司', icon: '🏢' },
    { type: '技能', icon: '🔧' },
    { type: '学校', icon: '🎓' },
    { type: '学历', icon: '📜' }
  ];
  
  // 创建选择器UI
  const selector = document.createElement('div');
  selector.className = 'rule-type-selector';
  
  ruleTypes.forEach(({ type, icon }) => {
    const typeOption = document.createElement('div');
    typeOption.className = 'rule-type-option';
    typeOption.innerHTML = `
      <div class="rule-type-icon">${icon}</div>
      <div class="rule-type-name">${type}</div>
    `;
    
    typeOption.addEventListener('click', () => {
      addNewRule(type, icon);
      selector.remove();
    });
    
    selector.appendChild(typeOption);
  });
  
  // 添加到页面
  document.body.appendChild(selector);
}

// 添加新规则
function addNewRule(type, icon) {
  const ruleId = 'rule_' + Date.now();
  const rulesContainer = document.getElementById('rules-container');
  
  const ruleCard = document.createElement('div');
  ruleCard.className = 'rule-card';
  ruleCard.dataset.ruleId = ruleId;
  ruleCard.dataset.ruleType = type;
  
  ruleCard.innerHTML = `
    <div class="rule-header">
      <div class="rule-icon">${icon}</div>
      <div class="rule-title">${type}</div>
      <div class="rule-toggle">
        <label class="switch">
          <input type="checkbox" checked class="rule-enabled">
          <span class="slider round"></span>
        </label>
      </div>
      <button class="delete-rule-btn">✕</button>
    </div>
    
    <div class="rule-body">
      <div class="keyword-input">
        <input type="text" placeholder="输入关键词，回车添加" class="tag-input">
        <div class="tags-container"></div>
      </div>
      
      <div class="importance-slider">
        <span>重要性：</span>
        <input type="range" min="1" max="4" value="2" class="range-slider">
        <span class="importance-label">一般</span>
      </div>
      
      <label class="must-match">
        <input type="checkbox" class="must-match-checkbox">
        <span>必须满足此条件</span>
      </label>
    </div>
  `;
  
  // 添加到容器
  rulesContainer.appendChild(ruleCard);
  
  // 初始化事件处理
  initRuleCardEvents(ruleCard);
}

// 初始化规则卡片事件
function initRuleCardEvents(ruleCard) {
  // 标签输入
  const tagInput = ruleCard.querySelector('.tag-input');
  const tagsContainer = ruleCard.querySelector('.tags-container');
  
  tagInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && tagInput.value.trim()) {
      addTag(tagsContainer, tagInput.value.trim());
      tagInput.value = '';
      e.preventDefault();
    }
  });
  
  // 重要性滑块
  const importanceSlider = ruleCard.querySelector('.range-slider');
  const importanceLabel = ruleCard.querySelector('.importance-label');
  
  importanceSlider.addEventListener('input', () => {
    const labels = ['不重要', '一般', '重要', '非常重要'];
    importanceLabel.textContent = labels[importanceSlider.value - 1];
  });
  
  // 删除规则按钮
  const deleteBtn = ruleCard.querySelector('.delete-rule-btn');
  deleteBtn.addEventListener('click', () => {
    if (confirm('确定要删除这条规则吗？')) {
      ruleCard.remove();
    }
  });
}

// 添加标签
function addTag(container, text) {
  const tag = document.createElement('span');
  tag.className = 'tag';
  tag.innerHTML = `
    ${text}
    <button class="remove-tag">×</button>
  `;
  
  // 移除标签事件
  tag.querySelector('.remove-tag').addEventListener('click', () => {
    tag.remove();
  });
  
  container.appendChild(tag);
}

// 收集规则数据
function collectRulesData() {
  const ruleCards = document.querySelectorAll('.rule-card');
  const rules = [];
  
  ruleCards.forEach(card => {
    // 只收集启用的规则
    const enabled = card.querySelector('.rule-enabled').checked;
    if (!enabled) return;
    
    // 收集标签
    const tags = [];
    card.querySelectorAll('.tag').forEach(tag => {
      tags.push(tag.textContent.trim());
    });
    
    // 跳过没有关键词的规则
    if (tags.length === 0) return;
    
    const rule = {
      id: card.dataset.ruleId,
      type: card.dataset.ruleType,
      keywords: tags,
      importance: parseInt(card.querySelector('.range-slider').value) * 25, // 转换为分数
      mustMatch: card.querySelector('.must-match-checkbox').checked,
      enabled: true
    };
    
    rules.push(rule);
  });
  
  // 全局设置
  const passScore = document.getElementById('pass-score').value;
  const autoMode = document.getElementById('auto-mode').checked;
  
  return {
    rules,
    passScore: parseInt(passScore),
    autoMode
  };
}
```

## 5. 界面改进

### 5.1 全局设置简化

```html
<div class="settings-panel">
  <h3>筛选设置</h3>
  
  <div class="setting-row">
    <label>通过分数：</label>
    <div class="score-slider-container">
      <input type="range" id="pass-score" min="0" max="100" value="60">
      <span id="score-value">60</span>
    </div>
  </div>
  
  <div class="setting-row">
    <label class="checkbox-label">
      <input type="checkbox" id="auto-mode">
      <span>自动模式（自动打招呼/跳过）</span>
    </label>
  </div>
</div>
```

### 5.2 测试界面简化

```html
<div class="test-panel">
  <div class="test-input">
    <h3>测试数据</h3>
    <textarea id="test-data" placeholder="粘贴候选人JSON数据..."></textarea>
    <button id="test-button">测试规则</button>
  </div>
  
  <div class="test-result">
    <h3>测试结果</h3>
    <div id="result-display">
      <!-- 结果将在这里显示 -->
    </div>
  </div>
</div>
```

## 6. 实施步骤

1. 创建新的简化规则引擎文件 `simple-rules-engine.ts`
2. 更新规则编辑器HTML结构，简化UI
3. 重写CSS样式，实现新的视觉设计
4. 实现标签式关键词输入组件
5. 整合Fuse.js进行匹配

## 7. 优点总结

1. **更简单的数据结构**：从复杂的嵌套条件简化为扁平的关键词列表
2. **口语化操作**：使用"岗位"、"技能"等直观术语替代技术术语
3. **降低认知负担**：4档重要性替代0-100权重，简化用户决策
4. **更好的视觉反馈**：标签和颜色提供直观的规则类型区分
5. **模糊匹配能力**：利用Fuse.js实现智能匹配，容忍拼写错误和近似表达 